#!/usr/bin/python
# Copyright (C) 2011 Ben Jeffrey. All Rights Reserved.
import Rules
import sys

Transform = Rules.Transform

def CycleThrough (WordList):
    Derivations = []
    for Word in WordList:               # For every word in the list,
        Derivatives = Transform(Word)   # get it's transformations,
        Derivations.extend(Derivatives)      # and put them in a big list.
    return Derivations                  # Return the list for the next cycle.

def Run (MaxCycles=10, StartWord='MI', EndWord='MU'):

    Derivatives = [StartWord]   # List of words
    Cycles = 0

    while EndWord not in Derivatives:

        Cycles += 1
        print 'Cycle:', Cycles, '   Derivations:', str(len(Derivatives))
        if Cycles >= MaxCycles: # Stop if we can't find it in given number of cycles.
            return 'Could not derive in %s cycles' % MaxCycles
        else:
            Derivatives.extend(CycleThrough(Derivatives))
                                            
    return (Cycles, StartWord, EndWord) # Returns a tuple at the end, if found.


if __name__ == '__main__':
    
    if len(sys.argv)<2:     #Instructions!
        print
        print " MU finds whether you can derive 'MU' from 'MI' using the rules"
        print " printed in Godel Escher Bach (hint - you can't) using a"
        print " breadth-first, brute-force method."
        print
        print " Arguments:"
        print "     1st argument is the number of derivation cycles to compute."
        print "     2nd argument is the starting string."
        print "     3rd argument is the string you want to achieve."
        print "i.e. To run 50 cycles and see if it produces 'MI' from 'MU', then"
        print "     at the command line, in the right directory, type:"
        print
        print "     ./MU 50 'MU' 'MI'"
        print
    else:
        print Run(int(sys.argv[1]), str(sys.argv[2]), str(sys.argv[3]))
